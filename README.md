Dockerized Flask + PostgreSQL Starter Code.

# Requirements:
* MacOS or Ubuntu
* Docker deamon installed and running

# How to start:

```
>mkdir db # create db folder
>docker-compose build # build project
>docker-compose up # starting project

This will execute all pending migrations.
Services is going to be accessable in browser via: localhost:7001/

```
# Create Migrations

Migrations are in the migrations folder in app. It uses Flask-Migrate which uses alembic under the hood.
You find alembics config in alembic.ini. We are generally happy with the default config.
The hash file names contain the actual migrations.

## Pre-requisits

For all changes you need to be in the docker container:
```shell
>> docker exec -it todo bash
```
and there in the app folder (the folder that contains the migrations folder).

## Init

Add the dependecy and code line:

```python
from flask_migrate import Migrate
migrate = Migrate(app, db)
```

Next, if you have not tables in your databse yet you can let Flask-Migrate create those entering:

```shell
> flask db init # (replaces use of) db.create_all()
```

An inital schema is created, much like an initial snapshot is created using git init in terms of version control.

## Add changes:

1. Change your db.Model instance.
2. Create a migration by entering: ```> flask db migrate ```
3. Changes to the models will be automatically detected and an new hash-file-named.py migrations file will be created in the migrations folder.
4. To execute the migrations so that the DB tables are updated accordingly we enter: ```flask db upgrade```

## Troubleshooting.

If the execution does not work directly, maybe try entering

```shell
> FLASK_APP=app:app flask db upgrade
```

Using the FLASK_APP variable gives the flask-command the context of the app-location as env variable FLASK_APP.


## Work with existing data

Lets assume you have a db with already existing data.
If you, for example try to add a column with porperty non-nullable, and you already have database entries, migrations do not work out of the box. What should the existing database entries values for that new column should be?
You have to modifiy the newly created hash-named migrations file. 

Example from e893426501d0_.py
```
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('todo', sa.Column('completed', sa.Boolean(), nullable=True))

    op.execute('UPDATE todo SET completed = False WHERE completed IS NULL;')
    op.alter_column('todo', 'completed', nullable=False)
```

In case of a mandadorty boolean being added, you could first modify the migrations file to add the new boolean column without the non-nullable property, then handle the already existing data and finally change the new column back to being non-nullable. Finally you have if migrations script when run results the desired changes to the database.

## (Todo) Working with already existing databas table

* add how to here!

## Resouces:
https://alembic.sqlalchemy.org/en/latest/
https://flask-migrate.readthedocs.io/en/latest/


# Testing

## Interactive Session for testing and inspecting:

```
> docker-compose run app python3 # opens interactive session in container
> from app.app import app # or more: (, db, Person) helps you interact with the system
```

You can do queries on Person table:

```
Person.query.all() # get all
Person.query.first() # get first record
Person.query.count() # get total count of all rows
Person.query.filter_by(name="Frank") # select person by name
person = Person(name="Bob")
db.session.add(person) # or db.session.add_all([person1, person2, ...]) for arrays to add person; pending changes
db.session.commit() # finally executes adding persons; commits transaction
```

# Explanation so Models:

## Common Model.query-examples
Model.query => provides all SELECT queries
Model.query.filter_by(..) => select * where (...)
Model.query.count => select count(*)
Model.query.filter(Model.attribute = 'value') => select * from xy where (..)
Model.query.filter(Model.attribute = 'value', Model2.attribute == 'value') => select * from xy, ab where (conditions on multiple tables)
Model.query.get(1) => get by primary key

Alternative: db.session.query(Model).join(Team)

## Bulk operations:
Model.query.filter(..).delete()

## Method chaining:
Model.query.filter(...).first() => like chaining where clauses
Model.query.join(...).filter_by().all() => like chaining where clauses

## INSERT, UPDATE, DELETE

user = User(name="John")

*INSERT:*
session.add(user)

*UPDATE:*
user.name = 'Bob'

*DELETE:*
session.delete(user)

**You can now either, commit or rollback:**
db.session.commit()
db.session.rollback()


# Enter database:

Start the system if you have not already:

```
> docker-compose up
```

Enter the db container executing psql using:

```
>  docker exec -it example_db_1 psql -U postgres
```


# Tips

* Update requirements.txt from pipenv:

```
> pipenv lock -r > requirements.txt`
```